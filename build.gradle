// java plugins
plugins {
    id 'org.unbroken-dome.test-sets' version '1.3.2'
}
apply plugin: 'java'
def jvmVersion = '1.8'
targetCompatibility = jvmVersion
sourceCompatibility = jvmVersion

// Project settings - change before running the createProject task
def namespace = 'hall.collin.christopher.javafx.globeviewer'
archivesBaseName = 'globeviewer'
def versionFileName = 'version.properties'

// customizing build folder
def sourceDir = 'src'
def resourceDir = 'resources'
def testDir = 'unit-test'
def integrationTestDir = 'integration-test'
def testResources = "${testDir}-${resourceDir}"
def integrationTestResources = "${integrationTestDir}-${resourceDir}"
def importDir = 'lib'
def buildDirName = 'build'
buildDir = buildDirName // buildDir is a file, not a string, unlike the other properties
libsDirName = 'jar'
distsDirName = 'distributions'
docsDirName = 'code-doc'
testResultsDirName = 'test-results'
testReportDirName = 'tests'
def runDir = 'run'
// add integration testing with the testsets plugin
testSets {
	integrationTest { dirName = integrationTestDir }
}
project.integrationTest {
	outputs.upToDateWhen { false }
}
tasks.withType(Test) {
	// fixes issue where integration results overwrite unit test results
	reports.html.destination = file("${reporting.baseDir}/${name}")
}
integrationTest.mustRunAfter test
//check.dependsOn integrationTest // optional: make build require successful integration test

// source folders
sourceSets {
	main {
		java {
			srcDirs = [sourceDir]
		}
		resources {
			srcDirs = [resourceDir]
		}
	}
	
	test {
		java {
			srcDirs = [testDir]
		}
		resources {
			srcDirs = [testResources]
		}
	}
	
	integrationTest {
		java {
			srcDirs = [integrationTestDir]
		}
		resources {
			srcDirs = [integrationTestResources]
		}
	}
}

// In this section you declare where to find the dependencies of your project
repositories {
	flatDir {
		dirs importDir // add libraries folder to build path
	}
	jcenter() // repo for 'standard' java tools like JUnit
	// mavenCentral() // repo with lots of goodies and LGPL/MIT/Apache open source libraries
}
 
dependencies {
	testCompile "junit:junit:+" // latest JUnit verion (whatever that might be)
	//compile name: 'xxx' // import xxx.jar from the libraries folder
	//compile "zzz.xyz:libname:version" // import artifactId "libname" in groupId "zzz.xyz" from Maven repository
	//integrationTestCompile "zzz.xyz:libname:version" // add specific dependency for integration tests
}

// add sources and javadocs to distribution package
task sourcesJar(type: Jar, dependsOn: classes) {
	classifier = 'sources'
	from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
	classifier = 'javadoc'
	from javadoc.destinationDir
}

artifacts {
	archives sourcesJar
	archives javadocJar
}

// version file stuff

def majorVersionKey = 'version.major'
def minorVersionKey = 'version.minor'
def buildVersionKey = 'version.build'
def namespaceDirPath = namespace.toString().replace('.','/')
def versionFilepath = "${resourceDir}/${namespaceDirPath}/${versionFileName}"
// customized behavior

compileJava.doFirst( { 
	incrementPropertyNumber("${projectDir}/${versionFilepath}", buildVersionKey)
	version = readVersionNumber("${projectDir}/${versionFilepath}",majorVersionKey,minorVersionKey,buildVersionKey)
})



///// utility functions and tasks /////



// functions
public String readVersionNumber( def filepath, def majorVersionKey, def minorVersionKey, def buildVersionKey ){
	Properties props = new Properties()
	File propsFile = new File(filepath)
	props.load(propsFile.newDataInputStream())
	def majorV = props.getProperty(majorVersionKey)
	def minorV = props.getProperty(minorVersionKey)
	def buildV = props.getProperty(buildVersionKey)
	return "${majorV}.${minorV}.${buildV}".toString()
}
public void incrementPropertyNumber( def filepath, def buildVersionKey ){
	Properties props = new Properties()
	File propsFile = new File(filepath)
	props.load(propsFile.newDataInputStream())
	Integer nextbuildnum = ( ((props.getProperty(buildVersionKey)) as BigDecimal) + 1 )
	props.setProperty(buildVersionKey, nextbuildnum.toString())
	props.store(propsFile.newWriter(), null)
}
public void makeFolder( def folderpath) {
	println "Creating directory: ${folderpath}"
	java.nio.file.Files.createDirectories(java.nio.file.Paths.get(folderpath.toString()))
}
public void writeToFile( def filepath, def contentList) {
	println "Writing to file: ${filepath}"
	File f = new File(filepath)
	contentList.each {
        f << ("${it}\n")
    }
}
public String fileName( def filepath) {
	return java.nio.file.Paths.get(filepath.toString()).getFileName().toString()
}
public String folderName( def filepath) {
	return java.nio.file.Paths.get(filepath.toString()).getParent().toString().replace('\\','/')
}
public String relativeTo( def filepath, def rootfilepath) {
	return java.nio.file.Paths.get(rootfilepath.toString()).relativize(java.nio.file.Paths.get(filepath.toString())).toString().replace('\\','/')
}
public String classPathToFilePath( def classPathString ) {
	return classPathString.toString().replace('.','/')
}

///// end of utility functions /////